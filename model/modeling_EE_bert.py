import math
import os
import warnings
from dataclasses import dataclass
from typing import Optional, Tuple

import torch
import torch.utils.checkpoint
from torch import nn
from torch.nn import CrossEntropyLoss, MSELoss
from transformers.activations import ACT2FN

from transformers.modeling_utils import (
    PreTrainedModel,
    apply_chunking_to_forward,
    find_pruneable_heads_and_indices,
    prune_linear_layer,
)

def compute_macs(attention_sentence_lengths, ffn_sentence_lengths, dim,max_length):
    def _layer_mac(attention_sentence_length, ffn_sentence_length, dim):
        attention_mac = 2 * dim * attention_sentence_length ** 2 # Q*V, attn*V
        attention_mac += 4 * dim ** 2 * attention_sentence_length
        ffn_mac = 8 * dim ** 2 * ffn_sentence_length
        return attention_mac + ffn_mac

    attention_sentence_length = max_length
    ffn_sentence_length=0
    mac = _layer_mac(attention_sentence_length, ffn_sentence_length, dim)
    for i in range(len(attention_sentence_lengths)):
        if i ==11:
            attention_sentence_length = 0
            ffn_sentence_length = ffn_sentence_lengths[i]
            mac += _layer_mac(attention_sentence_length, ffn_sentence_length, dim)
        else:
            attention_sentence_length = attention_sentence_lengths[i]
            ffn_sentence_length = ffn_sentence_lengths[i]
            mac += _layer_mac(attention_sentence_length, ffn_sentence_length, dim)
    baseline_mac = _layer_mac(max_length, max_length, dim) * 12
    return mac.cpu().tolist(), baseline_mac.cpu().tolist()


class BertSelfAttention(nn.Module):
    def __init__(self, config):
        super().__init__()
        if config.hidden_size % config.num_attention_heads != 0 and not hasattr(config, "embedding_size"):
            raise ValueError(
                "The hidden size (%d) is not a multiple of the number of attention "
                "heads (%d)" % (config.hidden_size, config.num_attention_heads)
            )

        self.num_attention_heads = config.num_attention_heads   #12
        self.attention_head_size = int(config.hidden_size / config.num_attention_heads)  #768/12=64
        self.all_head_size = self.num_attention_heads * self.attention_head_size  #768

        self.query = nn.Linear(config.hidden_size, self.all_head_size)   #768x768
        self.key = nn.Linear(config.hidden_size, self.all_head_size)
        self.value = nn.Linear(config.hidden_size, self.all_head_size)

        self.dropout = nn.Dropout(config.attention_probs_dropout_prob)  #0.1
        self.position_embedding_type = getattr(config, "position_embedding_type", "absolute")
        if self.position_embedding_type == "relative_key" or self.position_embedding_type == "relative_key_query":
            self.max_position_embeddings = config.max_position_embeddings
            self.distance_embedding = nn.Embedding(2 * config.max_position_embeddings - 1, self.attention_head_size)
        self.is_decoder = config.is_decoder
        self.tradeoff =  [1, 1, 1, 1, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5]

    def transpose_for_scores(self, x):
        new_x_shape = x.size()[:-1] + (self.num_attention_heads, self.attention_head_size)
        x = x.view(*new_x_shape)
        return x.permute(0, 2, 1, 3)

    def forward(
        self,
        hidden_states,
        attention_mask=None,
        head_mask=None,
        encoder_hidden_states=None,
        encoder_attention_mask=None,
        past_key_value=None,
        output_attentions=False,
        ee_ratio = None,
        index = None,
        reuse_cls_attention = None,
    ):
        B,N,D =hidden_states.shape
        mixed_query_layer = self.query(hidden_states)
        # If this is instantiated as a cross-attention module, the keys
        # and values come from an encoder; the attention mask needs to be
        # such that the encoder's padding tokens are not attended to.
        is_cross_attention = encoder_hidden_states is not None

        if is_cross_attention and past_key_value is not None:
            # reuse k,v, cross_attentions
            key_layer = past_key_value[0]
            value_layer = past_key_value[1]
            attention_mask = encoder_attention_mask
        elif is_cross_attention:
            key_layer = self.transpose_for_scores(self.key(encoder_hidden_states))
            value_layer = self.transpose_for_scores(self.value(encoder_hidden_states))
            attention_mask = encoder_attention_mask
        elif past_key_value is not None:
            key_layer = self.transpose_for_scores(self.key(hidden_states))
            value_layer = self.transpose_for_scores(self.value(hidden_states))
            key_layer = torch.cat([past_key_value[0], key_layer], dim=2)
            value_layer = torch.cat([past_key_value[1], value_layer], dim=2)
        else:
            key_layer = self.transpose_for_scores(self.key(hidden_states))
            value_layer = self.transpose_for_scores(self.value(hidden_states))

        query_layer = self.transpose_for_scores(mixed_query_layer)

        if self.is_decoder:
            # if cross_attention save Tuple(torch.Tensor, torch.Tensor) of all cross attention key/value_states.
            # Further calls to cross_attention layer can then reuse all cross-attention
            # key/value_states (first "if" case)
            # if uni-directional self-attention (decoder) save Tuple(torch.Tensor, torch.Tensor) of
            # all previous decoder key/value_states. Further calls to uni-directional self-attention
            # can concat previous decoder key/value_states to current projected key/value_states (third "elif" case)
            # if encoder bi-directional self-attention `past_key_value` is always `None`
            past_key_value = (key_layer, value_layer)

        # Take the dot product between "query" and "key" to get the raw attention scores.
        attention_scores = torch.matmul(query_layer, key_layer.transpose(-1, -2))  #(batch_size, num_attention_heads, sequence_length, sequence_length)


        if self.position_embedding_type == "relative_key" or self.position_embedding_type == "relative_key_query":
            seq_length = hidden_states.size()[1]
            position_ids_l = torch.arange(seq_length, dtype=torch.long, device=hidden_states.device).view(-1, 1)
            position_ids_r = torch.arange(seq_length, dtype=torch.long, device=hidden_states.device).view(1, -1)
            distance = position_ids_l - position_ids_r
            positional_embedding = self.distance_embedding(distance + self.max_position_embeddings - 1)
            positional_embedding = positional_embedding.to(dtype=query_layer.dtype)

            if self.position_embedding_type == "relative_key":
                relative_position_scores = torch.einsum("bhld,lrd->bhlr", query_layer, positional_embedding)
                attention_scores = attention_scores + relative_position_scores
            elif self.position_embedding_type == "relative_key_query":
                relative_position_scores_query = torch.einsum("bhld,lrd->bhlr", query_layer, positional_embedding)
                relative_position_scores_key = torch.einsum("bhrd,lrd->bhlr", key_layer, positional_embedding)
                attention_scores = attention_scores + relative_position_scores_query + relative_position_scores_key

        attention_scores = attention_scores / math.sqrt(self.attention_head_size)

        if attention_mask is not None:
            # Apply the attention mask is (precomputed for all layers in BertModel forward() function)
            attention_mask= attention_mask[:,:,:,:attention_scores.size(3)]
            attention_scores = attention_scores + attention_mask
        # Normalize the attention scores to probabilities.
        attention_probs = nn.Softmax(dim=-1)(attention_scores)

        # This is actually dropping out entire tokens to attend to, which might
        # seem a bit unusual, but is taken from the original Transformer paper.
        attention_probs = self.dropout(attention_probs)


        # Mask heads if we want to
        if head_mask is not None:
            attention_probs = attention_probs * head_mask
        context_layer = torch.matmul(attention_probs, value_layer)
        context_layer = context_layer.permute(0, 2, 1, 3).contiguous()
        new_context_layer_shape = context_layer.size()[:-2] + (self.all_head_size,)
        context_layer = context_layer.view(*new_context_layer_shape)
        outputs = (context_layer, attention_probs) if output_attentions else (context_layer,)

        left_tokens = N - 1
        if ee_ratio < 1:
            left_tokens = math.ceil(ee_ratio * (N - 1))
            if index == 0:
                reuse_cls_attention = attention_probs[:, :, 0, 1:]
                reuse_cls_attention = reuse_cls_attention.mean(dim=1)
            else:
                reuse_cls_attention = (1 - self.tradeoff[index]) * reuse_cls_attention[:,:N-1] + self.tradeoff[index] * attention_probs[:, :, 0, 1:].mean(dim=1)
            if left_tokens == N - 1:
                return outputs, None, None, None, left_tokens
            _, idx = torch.topk(reuse_cls_attention, left_tokens, dim=1, largest=True, sorted=True)
            indexs = idx.unsqueeze(-1).expand(-1, -1, D)

            return outputs, indexs, idx, reuse_cls_attention, left_tokens
        else:
            if index == 0:
                reuse_cls_attention = attention_probs[:, :, 0, 1:].mean(dim=1)
            else:
                reuse_cls_attention = (1 - self.tradeoff[index]) * reuse_cls_attention[:,:N-1] + self.tradeoff[index] * attention_probs[:, :, 0, 1:].mean(dim=1)


        return outputs, None, None,reuse_cls_attention, left_tokens


class BertSelfOutput(nn.Module):
    def __init__(self, config):
        super().__init__()
        self.dense = nn.Linear(config.hidden_size, config.hidden_size)
        self.LayerNorm = nn.LayerNorm(config.hidden_size, eps=config.layer_norm_eps)
        self.dropout = nn.Dropout(config.hidden_dropout_prob)

    def forward(self, hidden_states, input_tensor):
        hidden_states = self.dense(hidden_states)
        hidden_states = self.dropout(hidden_states)
        hidden_states = self.LayerNorm(hidden_states + input_tensor)
        return hidden_states

class BertAttention(nn.Module):
    def __init__(self, config):
        super().__init__()
        self.self = BertSelfAttention(config)
        self.output = BertSelfOutput(config)
        self.pruned_heads = set()

    def prune_heads(self, heads):
        if len(heads) == 0:
            return
        heads, index = find_pruneable_heads_and_indices(
            heads, self.self.num_attention_heads, self.self.attention_head_size, self.pruned_heads
        )

        # Prune linear layers
        self.self.query = prune_linear_layer(self.self.query, index)
        self.self.key = prune_linear_layer(self.self.key, index)
        self.self.value = prune_linear_layer(self.self.value, index)
        self.output.dense = prune_linear_layer(self.output.dense, index, dim=1)

        # Update hyper params and store pruned heads
        self.self.num_attention_heads = self.self.num_attention_heads - len(heads)
        self.self.all_head_size = self.self.attention_head_size * self.self.num_attention_heads
        self.pruned_heads = self.pruned_heads.union(heads)

    def forward(
        self,
        hidden_states,
        attention_mask=None,
        head_mask=None,
        encoder_hidden_states=None,
        encoder_attention_mask=None,
        past_key_value=None,
        output_attentions=False,
        ee_ratio = None,
        index = None,
        reuse_cls_attention= None,
    ):
        self_outputs, indexs, idx, cls_attn, left_tokens  = self.self(
            hidden_states,
            attention_mask,
            head_mask,
            encoder_hidden_states,
            encoder_attention_mask,
            past_key_value,
            output_attentions,
            ee_ratio =ee_ratio,
            index = index,
            reuse_cls_attention = reuse_cls_attention,
        )
        attention_output = self.output(self_outputs[0], hidden_states)
        outputs = attention_output   # add attentions if we output them

        return outputs,indexs, idx, cls_attn, left_tokens


class BertIntermediate(nn.Module):
    def __init__(self, config):
        super().__init__()
        self.dense = nn.Linear(config.hidden_size, config.intermediate_size)
        if isinstance(config.hidden_act, str):
            self.intermediate_act_fn = ACT2FN[config.hidden_act]
        else:
            self.intermediate_act_fn = config.hidden_act

    def forward(self, hidden_states):
        hidden_states = self.dense(hidden_states)
        hidden_states = self.intermediate_act_fn(hidden_states)
        return hidden_states


class BertOutput(nn.Module):
    def __init__(self, config):
        super().__init__()
        self.dense = nn.Linear(config.intermediate_size, config.hidden_size)
        self.LayerNorm = nn.LayerNorm(config.hidden_size, eps=config.layer_norm_eps)
        self.dropout = nn.Dropout(config.hidden_dropout_prob)

    def forward(self, hidden_states, input_tensor):
        hidden_states = self.dense(hidden_states)
        hidden_states = self.dropout(hidden_states)
        hidden_states = self.LayerNorm(hidden_states + input_tensor)
        return hidden_states

def complement_idx(idx, dim):
    a = torch.arange(dim, device=idx.device)
    ndim = idx.ndim
    dims = idx.shape
    n_idx = dims[-1]
    dims = dims[:-1] + (-1, )
    for i in range(1, ndim):
        a = a.unsqueeze(0)
    a = a.expand(*dims)
    masked = torch.scatter(a, -1, idx, 0)
    compl, _ = torch.sort(masked, dim=-1, descending=False)
    compl = compl.permute(-1, *tuple(range(ndim - 1)))
    compl = compl[n_idx:].permute(*(tuple(range(1, ndim)) + (0,)))
    return compl


class BertLayer(nn.Module):
    def __init__(self, config):
        super().__init__()
        self.chunk_size_feed_forward = config.chunk_size_feed_forward
        self.seq_len_dim = 1
        self.attention = BertAttention(config)
        self.is_decoder = config.is_decoder
        self.add_cross_attention = config.add_cross_attention
        if self.add_cross_attention:
            assert self.is_decoder, f"{self} should be used as a decoder model if cross attention is added"
            self.crossattention = BertAttention(config)
        self.intermediate = BertIntermediate(config)
        self.output = BertOutput(config)
        self.fuse_token= True

    def forward(
        self,
        hidden_states,
        attention_mask=None,
        head_mask=None,
        encoder_hidden_states=None,
        encoder_attention_mask=None,
        past_key_value=None,
        output_attentions=False,
        ee_ratio = None,
        index = None,
        reuse_cls_attention =None,
    ):
        # decoder uni-directional self-attention cached key/values tuple is at positions 1,2
        self_attn_past_key_value = past_key_value[:2] if past_key_value is not None else None
        B,N,D = hidden_states.shape

        self_attention_outputs,indexs, idx, cls_attn, left_tokens = self.attention(
            hidden_states,
            attention_mask,
            head_mask,
            output_attentions=output_attentions,
            past_key_value=self_attn_past_key_value,
            ee_ratio = ee_ratio,
            index =index,
            reuse_cls_attention = reuse_cls_attention,

        )
        attention_output = self_attention_outputs
        if indexs is not None:
            non_cls_tokens = attention_output[:, 1:]
            tokens_information = torch.gather(non_cls_tokens, dim=1, index=indexs)
            if self.fuse_token:
                compl = complement_idx(idx, N - 1)
                non_topk = torch.gather(non_cls_tokens, dim=1,index=compl.unsqueeze(-1).expand(-1, -1, D))
                non_topk_attn = torch.gather(cls_attn, dim=1, index=compl)
                non_topk_attn_avg = non_topk_attn.mean(dim=1).unsqueeze(-1)
                cls_attn = torch.cat([cls_attn[:,0:left_tokens],non_topk_attn_avg,cls_attn[:,left_tokens:]], dim=1)
                token_noinformarion = torch.sum(non_topk * non_topk_attn.unsqueeze(-1), dim=1,keepdim=True)
                attention_output = torch.cat([attention_output[:, 0:1], tokens_information, token_noinformarion], dim=1)
            else:
                attention_output= torch.cat([attention_output[:, 0:1], tokens_information], dim=1)
        layer_output = apply_chunking_to_forward(
            self.feed_forward_chunk, self.chunk_size_feed_forward, self.seq_len_dim, attention_output
        )
        outputs = layer_output
        return outputs, cls_attn,left_tokens

    def feed_forward_chunk(self, attention_output):
        intermediate_output = self.intermediate(attention_output)
        layer_output = self.output(intermediate_output, attention_output)
        return layer_output


